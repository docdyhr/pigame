#!/usr/bin/env bash

# This scripts calculates pi with bc and compaires it with your verion.

# Name: pigame
# Author: thomas@dyhr.com 
# Date: 6. April 2020
# Version: 1.2


## TODO:
# implement method where it's possible to see differences when False match
# can you use diff program?
#Default LENGTH of π: '3.141592653589793'
LENGTH=15


# Print Usage 
usage() {
    echo -e "Usage:\t$(basename ${0}) [-v] [-p][-l LENGTH] YOUR_PI" >&2
    echo -e "\tEvaluate your version of π (3.141.. )" >&2
    echo -e '\t-v          Increase verbosity.' >&2
    echo -e '\t-l LENGTH   Calculate π with LENGTH number of decimals.' >&2
    echo -e '\t-p          Show π.' >&2
    
    exit 1
}


# Print messages
# log() {
#     local MESSAGE="${@}"
#     if [[ "${VERBOSE}" = 'true' ]]
#     then
#         echo -e "${MESSAGE}"
#     fi
# }

print_results() {
    # Print results to STOUT
    if [[ "${VERBOSE}" = 'true' ]]
    then
        echo -e "π with ${DEC} decimals:\t${PI}"
        echo -e "Your version of π:\t${YOUR_PI}"
        if [[ "${PI}" = ${YOUR_PI} ]]
        then
            if [[ "${LENGTH}" -lt 15 ]]
            then
                echo 'Well done.'
            else
                echo 'Perfect!'
            fi
        else
            echo -e 'You can do better!'
        fi
    else
        echo "${PI}"
        echo "${YOUR_PI}"
        if [[ "${PI}" = ${YOUR_PI} ]]
        then
            echo 'True'
        else
            echo 'False'
        fi
    fi
}

# Calculate π
calc_pi() {
    # Avoid rounding and keep precision of π's last decimal by
    # adding 2 decimals and truncate with substring parameter expansion

    # Calculate π with ${SCALE} number of decimals using bc
    if [[ "${LENGTH}" -lt 4 ]]
    then
        PI=$(echo "scale=$(( LENGTH + 2 )); 4*a(1)" | bc -l)    # Bash arithmetic expansion.
    else
        PI=$(echo "scale=${LENGTH}; 4*a(1)" | bc -l)
    fi

    # Truncate with substring parameter expansion 3. equals 2 ie. reuse $LENGTH
    PI="${PI:0:LENGTH}"
}


# MENU: get command line options with getopts

# TODO:
# PROBLEM: The order of options matters.
# parameters are valuated top to down!!
# This affects the value of LENGTH and VERBOSE
# because they are inter dependant.

while getopts vl:p OPTION
do
    case ${OPTION} in
        v)
            VERBOSE='true'
            ;;
        l)
            LENGTH="${OPTARG}"
            # echo '# DEBUG:'
            # echo "LENGTH: ${LENGTH}"
            ;;
        p)
            calc_pi
            if [[ "${VERBOSE}" = 'true' ]]
            then
                echo -e "π with ${LENGTH} decimals:\t${PI}"
            else
                echo -e "${PI}"
            fi
            ;;
        ?)
            usage
            ;;
    esac
done


# Remove the options while leaving the remaining arguments.
shift "$(( OPTIND - 1 ))"

if [[ "${#}" -gt 1 ]]
then
    usage
fi

# Allow 1 positional parameter: YOUR_PI
if [[ "${#}" -eq 1 ]]  
then
    # Input Validation: only float numbers
    # TODO:
    # Check if Inut Validation is precise, if not the refactor
    if [[ "${1}" == *[^[:digit:].]* ]]
    then
        echo 'Error: Invalid Input.'
        usage
    fi

    # User version of π 
    YOUR_PI="${1}"

    # number of decimals
    LENGTH=$(echo ${1} | awk '{print length}')

    # π with $DEC number of decimals
    if [[ "${LENGTH}" -lt 4 ]]
    then
        DEC=${LENGTH}
    else
        DEC=$(( LENGTH - 2 ))   # Bash arithmetic expansion, only integers!
    fi
    
    # Calculate π
    calc_pi

    # Print results to STDOUT
    print_results

    exit 0
fi
